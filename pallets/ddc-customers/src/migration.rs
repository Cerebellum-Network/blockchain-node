use frame_support::{
	storage_alias,
	traits::{Get, GetStorageVersion, OnRuntimeUpgrade, StorageVersion},
	weights::Weight,
	Twox64Concat,
};
use log::info;
#[cfg(feature = "try-runtime")]
use sp_runtime::TryRuntimeError;

use super::*;

const LOG_TARGET: &str = "ddc-customers";

pub mod v0 {
	use frame_support::pallet_prelude::*;

	use super::*;

	#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo)]
	pub struct Bucket<AccountId> {
		bucket_id: BucketId,
		owner_id: AccountId,
		cluster_id: ClusterId,
		is_public: bool,
	}

	#[storage_alias]
	pub(super) type BucketsCount<T: Config> = StorageValue<crate::Pallet<T>, BucketId, ValueQuery>;
	// StorageValue<Value = BucketId, QueryKind = ValueQuery, OnEmpty = DefaultBucketCount<T>>;

	#[storage_alias]
	pub(super) type Buckets<T: Config> = StorageMap<
		crate::Pallet<T>,
		Twox64Concat,
		BucketId,
		Bucket<<T as frame_system::Config>::AccountId>,
		OptionQuery,
	>;
}

// Migrate to removable buckets
pub fn migrate_to_v1<T: Config>() -> Weight {
	let on_chain_version = Pallet::<T>::on_chain_storage_version();
	if on_chain_version == 0 {
		let count = v0::BucketsCount::<T>::get();
		info!(
			target: LOG_TARGET,
			" >>> Updating DDC Customers storage. Migrating {} buckets...", count
		);

		Buckets::<T>::translate::<v0::Bucket<T::AccountId>, _>(
			|bucket_id: BucketId, _bucket: v0::Bucket<T::AccountId>| {
				let bucket = Pallet::<T>::buckets(bucket_id).unwrap();
				info!(target: LOG_TARGET, "     Migrated bucket for bucket ID {:?}...", bucket_id);

				Some(Bucket {
					bucket_id: bucket.bucket_id,
					owner_id: bucket.owner_id,
					cluster_id: bucket.cluster_id,
					is_public: bucket.is_public,
					is_removed: false,
				})
			},
		);

		// Update storage version.
		StorageVersion::new(1).put::<Pallet<T>>();
		let count = v0::BucketsCount::<T>::get();
		info!(
			target: LOG_TARGET,
			" <<< DDC Customers storage updated! Migrated {} buckets âœ…", count
		);

		// 1 read from `translate` method + 1 read from the closure
		T::DbWeight::get().reads_writes(2 * count as u64 + 1, count as u64 + 1)
	} else {
		info!(target: LOG_TARGET, " >>> Unused migration!");
		Weight::zero()
	}
}

pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
	fn on_runtime_upgrade() -> Weight {
		migrate_to_v1::<T>()
	}

	// #[cfg(feature = "try-runtime")]
	// fn pre_upgrade() -> Result<Vec<u8>, TryRuntimeError> {
	//     frame_support::ensure!(
	// 			Pallet::<T>::on_chain_storage_version() == 0,
	// 			"must upgrade linearly"
	// 		);
	//     let prev_count = Asset::<T>::iter().count();
	//     Ok((prev_count as u32).encode())
	// }
	//
	// #[cfg(feature = "try-runtime")]
	// fn post_upgrade(prev_count: Vec<u8>) -> Result<(), TryRuntimeError> {
	//     let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
	//         "the state parameter should be something that was generated by pre_upgrade",
	//     );
	//     let post_count = Asset::<T>::iter().count() as u32;
	//     ensure!(
	// 			prev_count == post_count,
	// 			"the asset count before and after the migration should be the same"
	// 		);
	//
	//     let current_version = Pallet::<T>::current_storage_version();
	//     let onchain_version = Pallet::<T>::on_chain_storage_version();
	//
	//     frame_support::ensure!(current_version == 1, "must_upgrade");
	//     ensure!(
	// 			current_version == onchain_version,
	// 			"after migration, the current_version and onchain_version should be the same"
	// 		);
	//
	//     Asset::<T>::iter().try_for_each(|(_id, asset)| -> Result<(), TryRuntimeError> {
	//         ensure!(
	// 				asset.status == AssetStatus::Live || asset.status == AssetStatus::Frozen,
	// 				 "assets should only be live or frozen. None should be in destroying status, or undefined
	// state" 			);
	//         Ok(())
	//     })?;
	//     Ok(())
	// }
}
