pub mod v1 {
	use ddc_primitives::{ClusterId, ClusterStatus};
	use frame_support::{log, pallet_prelude::*, traits::OnRuntimeUpgrade, weights::Weight};
	use sp_runtime::Saturating;

	use crate::{
		cluster::{Cluster, ClusterProps},
		Clusters, Config, Pallet, LOG_TARGET,
	};

	#[derive(Decode)]
	pub struct OldCluster<AccountId> {
		pub cluster_id: ClusterId,
		pub manager_id: AccountId,
		pub reserve_id: AccountId,
		pub props: ClusterProps<AccountId>,
	}

	impl<AccountId> OldCluster<AccountId> {
		fn migrate_to_v1(self) -> Cluster<AccountId> {
			// all clusters are unbonded by default
			let status = ClusterStatus::Unbonded;
			Cluster {
				cluster_id: self.cluster_id,
				manager_id: self.manager_id,
				reserve_id: self.reserve_id,
				props: self.props,
				status,
			}
		}
	}

	pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
	impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
		fn on_runtime_upgrade() -> Weight {
			let current_version = Pallet::<T>::current_storage_version();
			let onchain_version = Pallet::<T>::on_chain_storage_version();
			if onchain_version == 0 && current_version == 1 {
				let mut translated = 0u64;
				Clusters::<T>::translate::<OldCluster<T::AccountId>, _>(|_key, old_value| {
					translated.saturating_inc();
					Some(old_value.migrate_to_v1())
				});
				current_version.put::<Pallet<T>>();
				log::info!(
					target: LOG_TARGET,
					"Upgraded {} pools, storage to version {:?}",
					translated,
					current_version
				);
				T::DbWeight::get().reads_writes(translated + 1, translated + 1)
			} else {
				log::info!(
					target: LOG_TARGET,
					"Migration did not execute. This probably should be removed"
				);
				T::DbWeight::get().reads(1)
			}
		}

		#[cfg(feature = "try-runtime")]
		fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
			frame_support::ensure!(
				Pallet::<T>::on_chain_storage_version() == 0,
				"must upgrade linearly"
			);
			let prev_count = Clusters::<T>::iter().count();
			Ok((prev_count as u32).encode())
		}

		#[cfg(feature = "try-runtime")]
		fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
			let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
				"the state parameter should be something that was generated by pre_upgrade",
			);
			let post_count = Clusters::<T>::iter().count() as u32;
			assert_eq!(
				prev_count, post_count,
				"the asset count before and after the migration should be the same"
			);

			let current_version = Pallet::<T>::current_storage_version();
			let onchain_version = Pallet::<T>::on_chain_storage_version();

			frame_support::ensure!(current_version == 1, "must_upgrade");
			assert_eq!(
				current_version, onchain_version,
				"after migration, the current_version and onchain_version should be the same"
			);

			Clusters::<T>::iter().for_each(|(_id, cluster)| {
				assert!(
					cluster.status == ClusterStatus::Unbonded,
					"cluster status should only be 'Unbonded' or 'Activated'."
				)
			});
			Ok(())
		}
	}
}
